# Defining and calling functions

As you can see, Kotlin uses the standard Java collection classes. This is good news for Java developers: Kotlin doesn’t reimplement collection classes. All of your existing knowledge about Java collections still applies here. It is worth noting, however, that unlike in Java, Kotlin’s collection interfaces are read only by default. We will explore further details on this topic as well as the mutable counterparts for these interfaces in chapter 8.

## Making functions easier to call

Imagine you need the elements to be separated by semicolons and surrounded by parentheses, instead of the brackets used by the default implementation: (1; 2; 3). To solve this, Java projects use third-party libraries, such as Guava and Apache Commons, or reimplement the logic inside the project. In Kotlin, a function to handle this is part of the standard library.

Another common Java problem is the overabundance of overloaded methods in some classes. Just look at java.lang.Thread (http://mng.bz/4KZC) and its eight constructors! The overloads can be provided for the sake of backward compatibility, the convenience of API users, or other reasons, but the end result is the same: duplication. The parameter names and types are repeated over and over, and if you want to be thorough, you also have to repeat most of the documentation in every overload. At the same time, if you call an overload that omits some parameters, it’s not always clear which values are used for them.


Default values and Java
Given that Java doesn’t have the concept of default parameter values, you have to specify all the parameter values explicitly when you call a Kotlin function with default parameter values from Java. If you frequently need to call a function from Java and want to make it easier to use for Java callers, you can annotate it with @JvmOverloads.
This instructs the compiler to generate Java overloaded methods, omitting each of the parameters one by one, starting from the last one. For example, you may annotate your joinToString function with @JvmOverloads, as shown in the following listing.


In Kotlin, you don’t need to create all those meaningless classes. Instead, you can place functions directly at the top level of a source file, outside of any class. Such functions are still members of the package declared at the top of the file, and you still need to import them if you want to call them from other packages, but the unnecessary extra level of nesting no longer exists.

```kotlin
package strings

fun joinToString( /* ... */ ): String { /* ... */ }
```

Changing the file class name
By default, the class name generated by the compiler corresponds to the filename, together with a Kt suffix. To change the name of the generated class that contains Kotlin top-level functions, add a file-wide annotation: @file:JvmName("..."). Place it at the beginning of the file, before the package name:.

```kotlin
@file:JvmName("StringFunctions")
 
package strings
 
fun joinToString(/* ... */): String { /* ... */ }
```

Top-level properties
Just like functions, properties can be placed at the top level of a file. Storing individual pieces of data outside of a class isn’t needed as often but is still useful. For example, you can use a var property to count the number of times some operation has been performed:

```kotlin
var opCount = 0
 
fun performOperation() {
    opCount++
    // ...
}
 
fun reportOperationCount() {
    println("Operation performed $opCount times")
}
```

The value of such a property will be stored in a static field.

**Figure 3.1** In an extension function declaration, the *receiver type* is the type on which the extension is defined. 
You use it to specify the type your function extends. The *receiver object* is the instance of that type. 
You use it to access properties and methods of the type you’re extending.

```kotlin
Receiver type　　　　　　　　　　　Receiver object
   　　\　　　　　　　　　　　　　　　　　　/
fun String.lastChar(): Char = this.get(this.length - 1)
```

In the body of an extension function, you use this the same way you would use it in a method. And as in a regular method, you can omit it:

```kotlin
package strings
 
fun String.lastChar(): Char = get(length - 1)
```

In the extension function, you can directly access the methods and properties of the class you’re extending, as in methods defined in the class itself. Note that extension functions don’t allow you to break encapsulation. Unlike methods defined in the class, extension functions don’t have access to private or protected members of the class.

You can change the name of the class or function you’re importing using the as keyword:

```kotlin
import strings.lastChar as last

val c = "Kotlin".last()
```

Calling extension functions from Java

Under the hood, an extension function is a static method that accepts the receiver object as its first argument. Calling it doesn’t involve creating adapter objects or any other run-time overhead.


Declaring `joinToString()` as an extension

```kotlin
fun <T> Collection<T>.joinToString(
        separator: String = ", ",
        prefix: String = "",
        postfix: String = ""
): String {
    val result = StringBuilder(prefix)
 
    for ((index, element) in this.withIndex()) {
        if (index > 0) result.append(separator)
        result.append(element)
    }
 
    result.append(postfix)
    return result.toString()
}
 
fun main() {
    val list = listOf(1, 2, 3)
    println(
        list.joinToString(
            separator = "; ",
            prefix = "(",
            postfix = ")"
        )
    )
    // (1; 2; 3)
}
```

Method overriding in Kotlin works as usual for member functions, but you can’t override an extension function. 

```kotlin
fun View.showOff() = println("I'm a view!")
fun Button.showOff() = println("I'm a button!")
 
fun main() {
    val view: View = Button()
    view.showOff()
    // I'm a view!
}
```

It might help to recall that an extension function is compiled to a static function in Java with the receiver as the first argument. Java would choose the function the same way:


```java
/* Java */
class Demo {
    public static void main(String[] args) {
        View view = new Button();
        ExtensionsKt.showOff(view);
        // I'm a view!
    }
}
```

## Extension properties

Declaring a mutable extension property
```kotlin
var StringBuilder.lastChar: Char
    get() = this.get(length - 1)
    set(value) {
        this.setCharAt(length - 1, value)
    }
```

## Working with collections: varargs, infix calls, and library support

- The vararg keyword, which allows you to declare a function taking an arbitrary number of arguments
- An infix notation that lets you call some one-argument functions without ceremony
- Destructuring declarations that allow you to unpack a single composite value into multiple variables

 